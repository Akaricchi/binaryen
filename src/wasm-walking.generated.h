  /*
   * Copyright 2020 WebAssembly Community Group participants
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   *     http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   */

  //=============================================================================
  // This is an AUTOGENERATED file, even though it looks human-readable! Do not
  // edit it by hand, instead edit the generator, gen-exprs.py
  //
  // You can and should treat it like human-written code in all other ways,
  // though, like reviewing it in a PR, etc.
  //=============================================================================

case Expression::NopId: {
  self->pushTask(SubType::doVisitNop, currp);
  break;
}
case Expression::BlockId: {
  self->pushTask(SubType::doVisitBlock, currp);
  auto* cast = curr->cast<Block>();
  auto& list = cast->list;
  for (int i = int(list.size()) - 1; i >= 0; i--) {
    self->pushTask(SubType::scan, &list[i]);
  }
  break;
}
case Expression::IfId: {
  self->pushTask(SubType::doVisitIf, currp);
  auto* cast = curr->cast<If>();
  self->pushTask(SubType::scan, &cast->ifFalse);
  self->pushTask(SubType::scan, &cast->ifTrue);
  self->pushTask(SubType::scan, &cast->condition);
  break;
}
case Expression::LoopId: {
  self->pushTask(SubType::doVisitLoop, currp);
  auto* cast = curr->cast<Loop>();
  self->pushTask(SubType::scan, &cast->body);
  break;
}
case Expression::BreakId: {
  self->pushTask(SubType::doVisitBreak, currp);
  auto* cast = curr->cast<Break>();
  self->pushTask(SubType::scan, &cast->condition);
  self->pushTask(SubType::scan, &cast->value);
  break;
}
case Expression::SwitchId: {
  self->pushTask(SubType::doVisitSwitch, currp);
  auto* cast = curr->cast<Switch>();
  self->pushTask(SubType::scan, &cast->condition);
  self->pushTask(SubType::scan, &cast->value);
  break;
}
case Expression::CallId: {
  self->pushTask(SubType::doVisitCall, currp);
  auto* cast = curr->cast<Call>();
  auto& list = cast->operands;
  for (int i = int(list.size()) - 1; i >= 0; i--) {
    self->pushTask(SubType::scan, &list[i]);
  }
  break;
}
case Expression::CallIndirectId: {
  self->pushTask(SubType::doVisitCallIndirect, currp);
  auto* cast = curr->cast<CallIndirect>();
  self->pushTask(SubType::scan, &cast->target);
  auto& list = cast->operands;
  for (int i = int(list.size()) - 1; i >= 0; i--) {
    self->pushTask(SubType::scan, &list[i]);
  }
  break;
}
case Expression::LocalGetId: {
  self->pushTask(SubType::doVisitLocalGet, currp);
  break;
}
case Expression::LocalSetId: {
  self->pushTask(SubType::doVisitLocalSet, currp);
  auto* cast = curr->cast<LocalSet>();
  self->pushTask(SubType::scan, &cast->value);
  break;
}
case Expression::GlobalGetId: {
  self->pushTask(SubType::doVisitGlobalGet, currp);
  break;
}
case Expression::GlobalSetId: {
  self->pushTask(SubType::doVisitGlobalSet, currp);
  auto* cast = curr->cast<GlobalSet>();
  self->pushTask(SubType::scan, &cast->value);
  break;
}
case Expression::LoadId: {
  self->pushTask(SubType::doVisitLoad, currp);
  auto* cast = curr->cast<Load>();
  self->pushTask(SubType::scan, &cast->ptr);
  break;
}
case Expression::StoreId: {
  self->pushTask(SubType::doVisitStore, currp);
  auto* cast = curr->cast<Store>();
  self->pushTask(SubType::scan, &cast->value);
  self->pushTask(SubType::scan, &cast->ptr);
  break;
}
case Expression::AtomicRMWId: {
  self->pushTask(SubType::doVisitAtomicRMW, currp);
  auto* cast = curr->cast<AtomicRMW>();
  self->pushTask(SubType::scan, &cast->value);
  self->pushTask(SubType::scan, &cast->ptr);
  break;
}
case Expression::AtomicCmpxchgId: {
  self->pushTask(SubType::doVisitAtomicCmpxchg, currp);
  auto* cast = curr->cast<AtomicCmpxchg>();
  self->pushTask(SubType::scan, &cast->replacement);
  self->pushTask(SubType::scan, &cast->expected);
  self->pushTask(SubType::scan, &cast->ptr);
  break;
}
case Expression::AtomicWaitId: {
  self->pushTask(SubType::doVisitAtomicWait, currp);
  auto* cast = curr->cast<AtomicWait>();
  self->pushTask(SubType::scan, &cast->timeout);
  self->pushTask(SubType::scan, &cast->expected);
  self->pushTask(SubType::scan, &cast->ptr);
  break;
}
case Expression::AtomicNotifyId: {
  self->pushTask(SubType::doVisitAtomicNotify, currp);
  auto* cast = curr->cast<AtomicNotify>();
  self->pushTask(SubType::scan, &cast->notifyCount);
  self->pushTask(SubType::scan, &cast->ptr);
  break;
}
case Expression::AtomicFenceId: {
  self->pushTask(SubType::doVisitAtomicFence, currp);
  break;
}
case Expression::SIMDExtractId: {
  self->pushTask(SubType::doVisitSIMDExtract, currp);
  auto* cast = curr->cast<SIMDExtract>();
  self->pushTask(SubType::scan, &cast->vec);
  break;
}
case Expression::SIMDReplaceId: {
  self->pushTask(SubType::doVisitSIMDReplace, currp);
  auto* cast = curr->cast<SIMDReplace>();
  self->pushTask(SubType::scan, &cast->value);
  self->pushTask(SubType::scan, &cast->vec);
  break;
}
case Expression::SIMDShuffleId: {
  self->pushTask(SubType::doVisitSIMDShuffle, currp);
  auto* cast = curr->cast<SIMDShuffle>();
  self->pushTask(SubType::scan, &cast->right);
  self->pushTask(SubType::scan, &cast->left);
  break;
}
case Expression::SIMDTernaryId: {
  self->pushTask(SubType::doVisitSIMDTernary, currp);
  auto* cast = curr->cast<SIMDTernary>();
  self->pushTask(SubType::scan, &cast->c);
  self->pushTask(SubType::scan, &cast->b);
  self->pushTask(SubType::scan, &cast->a);
  break;
}
case Expression::SIMDShiftId: {
  self->pushTask(SubType::doVisitSIMDShift, currp);
  auto* cast = curr->cast<SIMDShift>();
  self->pushTask(SubType::scan, &cast->shift);
  self->pushTask(SubType::scan, &cast->vec);
  break;
}
case Expression::SIMDLoadId: {
  self->pushTask(SubType::doVisitSIMDLoad, currp);
  auto* cast = curr->cast<SIMDLoad>();
  self->pushTask(SubType::scan, &cast->ptr);
  break;
}
case Expression::MemoryInitId: {
  self->pushTask(SubType::doVisitMemoryInit, currp);
  auto* cast = curr->cast<MemoryInit>();
  self->pushTask(SubType::scan, &cast->size);
  self->pushTask(SubType::scan, &cast->offset);
  self->pushTask(SubType::scan, &cast->dest);
  break;
}
case Expression::DataDropId: {
  self->pushTask(SubType::doVisitDataDrop, currp);
  break;
}
case Expression::MemoryCopyId: {
  self->pushTask(SubType::doVisitMemoryCopy, currp);
  auto* cast = curr->cast<MemoryCopy>();
  self->pushTask(SubType::scan, &cast->size);
  self->pushTask(SubType::scan, &cast->source);
  self->pushTask(SubType::scan, &cast->dest);
  break;
}
case Expression::MemoryFillId: {
  self->pushTask(SubType::doVisitMemoryFill, currp);
  auto* cast = curr->cast<MemoryFill>();
  self->pushTask(SubType::scan, &cast->size);
  self->pushTask(SubType::scan, &cast->value);
  self->pushTask(SubType::scan, &cast->dest);
  break;
}
case Expression::ConstId: {
  self->pushTask(SubType::doVisitConst, currp);
  break;
}
case Expression::UnaryId: {
  self->pushTask(SubType::doVisitUnary, currp);
  auto* cast = curr->cast<Unary>();
  self->pushTask(SubType::scan, &cast->value);
  break;
}
case Expression::BinaryId: {
  self->pushTask(SubType::doVisitBinary, currp);
  auto* cast = curr->cast<Binary>();
  self->pushTask(SubType::scan, &cast->right);
  self->pushTask(SubType::scan, &cast->left);
  break;
}
case Expression::SelectId: {
  self->pushTask(SubType::doVisitSelect, currp);
  auto* cast = curr->cast<Select>();
  self->pushTask(SubType::scan, &cast->condition);
  self->pushTask(SubType::scan, &cast->ifFalse);
  self->pushTask(SubType::scan, &cast->ifTrue);
  break;
}
case Expression::DropId: {
  self->pushTask(SubType::doVisitDrop, currp);
  auto* cast = curr->cast<Drop>();
  self->pushTask(SubType::scan, &cast->value);
  break;
}
case Expression::ReturnId: {
  self->pushTask(SubType::doVisitReturn, currp);
  auto* cast = curr->cast<Return>();
  self->pushTask(SubType::scan, &cast->value);
  break;
}
case Expression::MemorySizeId: {
  self->pushTask(SubType::doVisitMemorySize, currp);
  break;
}
case Expression::MemoryGrowId: {
  self->pushTask(SubType::doVisitMemoryGrow, currp);
  auto* cast = curr->cast<MemoryGrow>();
  self->pushTask(SubType::scan, &cast->delta);
  break;
}
case Expression::UnreachableId: {
  self->pushTask(SubType::doVisitUnreachable, currp);
  break;
}
case Expression::PopId: {
  self->pushTask(SubType::doVisitPop, currp);
  break;
}
case Expression::RefNullId: {
  self->pushTask(SubType::doVisitRefNull, currp);
  break;
}
case Expression::RefIsNullId: {
  self->pushTask(SubType::doVisitRefIsNull, currp);
  auto* cast = curr->cast<RefIsNull>();
  self->pushTask(SubType::scan, &cast->value);
  break;
}
case Expression::RefFuncId: {
  self->pushTask(SubType::doVisitRefFunc, currp);
  break;
}
case Expression::RefEqId: {
  self->pushTask(SubType::doVisitRefEq, currp);
  auto* cast = curr->cast<RefEq>();
  self->pushTask(SubType::scan, &cast->right);
  self->pushTask(SubType::scan, &cast->left);
  break;
}
case Expression::TryId: {
  self->pushTask(SubType::doVisitTry, currp);
  auto* cast = curr->cast<Try>();
  self->pushTask(SubType::scan, &cast->catchBody);
  self->pushTask(SubType::scan, &cast->body);
  break;
}
case Expression::ThrowId: {
  self->pushTask(SubType::doVisitThrow, currp);
  auto* cast = curr->cast<Throw>();
  auto& list = cast->operands;
  for (int i = int(list.size()) - 1; i >= 0; i--) {
    self->pushTask(SubType::scan, &list[i]);
  }
  break;
}
case Expression::RethrowId: {
  self->pushTask(SubType::doVisitRethrow, currp);
  auto* cast = curr->cast<Rethrow>();
  self->pushTask(SubType::scan, &cast->exnref);
  break;
}
case Expression::BrOnExnId: {
  self->pushTask(SubType::doVisitBrOnExn, currp);
  auto* cast = curr->cast<BrOnExn>();
  self->pushTask(SubType::scan, &cast->exnref);
  break;
}
case Expression::TupleMakeId: {
  self->pushTask(SubType::doVisitTupleMake, currp);
  auto* cast = curr->cast<TupleMake>();
  auto& list = cast->operands;
  for (int i = int(list.size()) - 1; i >= 0; i--) {
    self->pushTask(SubType::scan, &list[i]);
  }
  break;
}
case Expression::TupleExtractId: {
  self->pushTask(SubType::doVisitTupleExtract, currp);
  auto* cast = curr->cast<TupleExtract>();
  self->pushTask(SubType::scan, &cast->tuple);
  break;
}
case Expression::I31NewId: {
  self->pushTask(SubType::doVisitI31New, currp);
  auto* cast = curr->cast<I31New>();
  self->pushTask(SubType::scan, &cast->value);
  break;
}
case Expression::I31GetId: {
  self->pushTask(SubType::doVisitI31Get, currp);
  auto* cast = curr->cast<I31Get>();
  self->pushTask(SubType::scan, &cast->i31);
  break;
}
case Expression::RefTestId: {
  self->pushTask(SubType::doVisitRefTest, currp);
  break;
}
case Expression::RefCastId: {
  self->pushTask(SubType::doVisitRefCast, currp);
  break;
}
case Expression::BrOnCastId: {
  self->pushTask(SubType::doVisitBrOnCast, currp);
  break;
}
case Expression::RttCanonId: {
  self->pushTask(SubType::doVisitRttCanon, currp);
  break;
}
case Expression::RttSubId: {
  self->pushTask(SubType::doVisitRttSub, currp);
  break;
}
case Expression::StructNewId: {
  self->pushTask(SubType::doVisitStructNew, currp);
  break;
}
case Expression::StructGetId: {
  self->pushTask(SubType::doVisitStructGet, currp);
  break;
}
case Expression::StructSetId: {
  self->pushTask(SubType::doVisitStructSet, currp);
  break;
}
case Expression::ArrayNewId: {
  self->pushTask(SubType::doVisitArrayNew, currp);
  break;
}
case Expression::ArrayGetId: {
  self->pushTask(SubType::doVisitArrayGet, currp);
  break;
}
case Expression::ArraySetId: {
  self->pushTask(SubType::doVisitArraySet, currp);
  break;
}
case Expression::ArrayLenId: {
  self->pushTask(SubType::doVisitArrayLen, currp);
  break;
}
