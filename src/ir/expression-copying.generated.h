  /*
   * Copyright 2020 WebAssembly Community Group participants
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   *     http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   */

  //=============================================================================
  // This is an AUTOGENERATED file, even though it looks human-readable! Do not
  // edit it by hand, instead edit the generator, gen-exprs.py
  //
  // You can and should treat it like human-written code in all other ways,
  // though, like reviewing it in a PR, etc.
  //=============================================================================

case Expression::NopId: {
  auto* source = task.source->cast<Nop>();
  auto* copy = wasm.allocator.alloc<Nop>();
  *task.destPointer = copy;
  copy->type = source->type;
  break;
}
case Expression::BlockId: {
  auto* source = task.source->cast<Block>();
  auto* copy = wasm.allocator.alloc<Block>();
  *task.destPointer = copy;
  copy->name = source->name;
  copy->list.resize(source->list.size());
  for (Index i = 0; i < source->list.size(); i++) {
    tasks.push_back({source->list[i], &copy->list[i]});
  }
  copy->type = source->type;
  break;
}
case Expression::IfId: {
  auto* source = task.source->cast<If>();
  auto* copy = wasm.allocator.alloc<If>();
  *task.destPointer = copy;
  tasks.push_back({source->condition, &copy->condition});
  tasks.push_back({source->ifTrue, &copy->ifTrue});
  tasks.push_back({source->ifFalse, &copy->ifFalse});
  copy->type = source->type;
  break;
}
case Expression::LoopId: {
  auto* source = task.source->cast<Loop>();
  auto* copy = wasm.allocator.alloc<Loop>();
  *task.destPointer = copy;
  copy->name = source->name;
  tasks.push_back({source->body, &copy->body});
  copy->type = source->type;
  break;
}
case Expression::BreakId: {
  auto* source = task.source->cast<Break>();
  auto* copy = wasm.allocator.alloc<Break>();
  *task.destPointer = copy;
  copy->name = source->name;
  tasks.push_back({source->value, &copy->value});
  tasks.push_back({source->condition, &copy->condition});
  copy->type = source->type;
  break;
}
case Expression::SwitchId: {
  auto* source = task.source->cast<Switch>();
  auto* copy = wasm.allocator.alloc<Switch>();
  *task.destPointer = copy;
  copy->targets = source->targets;
  copy->default_ = source->default_;
  tasks.push_back({source->value, &copy->value});
  tasks.push_back({source->condition, &copy->condition});
  copy->type = source->type;
  break;
}
case Expression::CallId: {
  auto* source = task.source->cast<Call>();
  auto* copy = wasm.allocator.alloc<Call>();
  *task.destPointer = copy;
  copy->operands.resize(source->operands.size());
  for (Index i = 0; i < source->operands.size(); i++) {
    tasks.push_back({source->operands[i], &copy->operands[i]});
  }
  copy->target = source->target;
  copy->isReturn = source->isReturn;
  copy->type = source->type;
  break;
}
case Expression::CallIndirectId: {
  auto* source = task.source->cast<CallIndirect>();
  auto* copy = wasm.allocator.alloc<CallIndirect>();
  *task.destPointer = copy;
  copy->sig = source->sig;
  copy->operands.resize(source->operands.size());
  for (Index i = 0; i < source->operands.size(); i++) {
    tasks.push_back({source->operands[i], &copy->operands[i]});
  }
  tasks.push_back({source->target, &copy->target});
  copy->isReturn = source->isReturn;
  copy->type = source->type;
  break;
}
case Expression::LocalGetId: {
  auto* source = task.source->cast<LocalGet>();
  auto* copy = wasm.allocator.alloc<LocalGet>();
  *task.destPointer = copy;
  copy->index = source->index;
  copy->type = source->type;
  break;
}
case Expression::LocalSetId: {
  auto* source = task.source->cast<LocalSet>();
  auto* copy = wasm.allocator.alloc<LocalSet>();
  *task.destPointer = copy;
  copy->index = source->index;
  tasks.push_back({source->value, &copy->value});
  copy->type = source->type;
  break;
}
case Expression::GlobalGetId: {
  auto* source = task.source->cast<GlobalGet>();
  auto* copy = wasm.allocator.alloc<GlobalGet>();
  *task.destPointer = copy;
  copy->name = source->name;
  copy->type = source->type;
  break;
}
case Expression::GlobalSetId: {
  auto* source = task.source->cast<GlobalSet>();
  auto* copy = wasm.allocator.alloc<GlobalSet>();
  *task.destPointer = copy;
  copy->name = source->name;
  tasks.push_back({source->value, &copy->value});
  copy->type = source->type;
  break;
}
case Expression::LoadId: {
  auto* source = task.source->cast<Load>();
  auto* copy = wasm.allocator.alloc<Load>();
  *task.destPointer = copy;
  copy->bytes = source->bytes;
  copy->signed_ = source->signed_;
  copy->offset = source->offset;
  copy->align = source->align;
  copy->isAtomic = source->isAtomic;
  tasks.push_back({source->ptr, &copy->ptr});
  copy->type = source->type;
  break;
}
case Expression::StoreId: {
  auto* source = task.source->cast<Store>();
  auto* copy = wasm.allocator.alloc<Store>();
  *task.destPointer = copy;
  copy->bytes = source->bytes;
  copy->offset = source->offset;
  copy->align = source->align;
  copy->isAtomic = source->isAtomic;
  tasks.push_back({source->ptr, &copy->ptr});
  tasks.push_back({source->value, &copy->value});
  copy->valueType = source->valueType;
  copy->type = source->type;
  break;
}
case Expression::AtomicRMWId: {
  auto* source = task.source->cast<AtomicRMW>();
  auto* copy = wasm.allocator.alloc<AtomicRMW>();
  *task.destPointer = copy;
  copy->op = source->op;
  copy->bytes = source->bytes;
  copy->offset = source->offset;
  tasks.push_back({source->ptr, &copy->ptr});
  tasks.push_back({source->value, &copy->value});
  copy->type = source->type;
  break;
}
case Expression::AtomicCmpxchgId: {
  auto* source = task.source->cast<AtomicCmpxchg>();
  auto* copy = wasm.allocator.alloc<AtomicCmpxchg>();
  *task.destPointer = copy;
  copy->bytes = source->bytes;
  copy->offset = source->offset;
  tasks.push_back({source->ptr, &copy->ptr});
  tasks.push_back({source->expected, &copy->expected});
  tasks.push_back({source->replacement, &copy->replacement});
  copy->type = source->type;
  break;
}
case Expression::AtomicWaitId: {
  auto* source = task.source->cast<AtomicWait>();
  auto* copy = wasm.allocator.alloc<AtomicWait>();
  *task.destPointer = copy;
  copy->offset = source->offset;
  tasks.push_back({source->ptr, &copy->ptr});
  tasks.push_back({source->expected, &copy->expected});
  tasks.push_back({source->timeout, &copy->timeout});
  copy->expectedType = source->expectedType;
  copy->type = source->type;
  break;
}
case Expression::AtomicNotifyId: {
  auto* source = task.source->cast<AtomicNotify>();
  auto* copy = wasm.allocator.alloc<AtomicNotify>();
  *task.destPointer = copy;
  copy->offset = source->offset;
  tasks.push_back({source->ptr, &copy->ptr});
  tasks.push_back({source->notifyCount, &copy->notifyCount});
  copy->type = source->type;
  break;
}
case Expression::AtomicFenceId: {
  auto* source = task.source->cast<AtomicFence>();
  auto* copy = wasm.allocator.alloc<AtomicFence>();
  *task.destPointer = copy;
  copy->order = source->order;
  copy->type = source->type;
  break;
}
case Expression::SIMDExtractId: {
  auto* source = task.source->cast<SIMDExtract>();
  auto* copy = wasm.allocator.alloc<SIMDExtract>();
  *task.destPointer = copy;
  copy->op = source->op;
  tasks.push_back({source->vec, &copy->vec});
  copy->index = source->index;
  copy->type = source->type;
  break;
}
case Expression::SIMDReplaceId: {
  auto* source = task.source->cast<SIMDReplace>();
  auto* copy = wasm.allocator.alloc<SIMDReplace>();
  *task.destPointer = copy;
  copy->op = source->op;
  tasks.push_back({source->vec, &copy->vec});
  copy->index = source->index;
  tasks.push_back({source->value, &copy->value});
  copy->type = source->type;
  break;
}
case Expression::SIMDShuffleId: {
  auto* source = task.source->cast<SIMDShuffle>();
  auto* copy = wasm.allocator.alloc<SIMDShuffle>();
  *task.destPointer = copy;
  tasks.push_back({source->left, &copy->left});
  tasks.push_back({source->right, &copy->right});
  copy->mask = source->mask;
  copy->type = source->type;
  break;
}
case Expression::SIMDTernaryId: {
  auto* source = task.source->cast<SIMDTernary>();
  auto* copy = wasm.allocator.alloc<SIMDTernary>();
  *task.destPointer = copy;
  copy->op = source->op;
  tasks.push_back({source->a, &copy->a});
  tasks.push_back({source->b, &copy->b});
  tasks.push_back({source->c, &copy->c});
  copy->type = source->type;
  break;
}
case Expression::SIMDShiftId: {
  auto* source = task.source->cast<SIMDShift>();
  auto* copy = wasm.allocator.alloc<SIMDShift>();
  *task.destPointer = copy;
  copy->op = source->op;
  tasks.push_back({source->vec, &copy->vec});
  tasks.push_back({source->shift, &copy->shift});
  copy->type = source->type;
  break;
}
case Expression::SIMDLoadId: {
  auto* source = task.source->cast<SIMDLoad>();
  auto* copy = wasm.allocator.alloc<SIMDLoad>();
  *task.destPointer = copy;
  copy->op = source->op;
  copy->offset = source->offset;
  copy->align = source->align;
  tasks.push_back({source->ptr, &copy->ptr});
  copy->type = source->type;
  break;
}
case Expression::MemoryInitId: {
  auto* source = task.source->cast<MemoryInit>();
  auto* copy = wasm.allocator.alloc<MemoryInit>();
  *task.destPointer = copy;
  copy->segment = source->segment;
  tasks.push_back({source->dest, &copy->dest});
  tasks.push_back({source->offset, &copy->offset});
  tasks.push_back({source->size, &copy->size});
  copy->type = source->type;
  break;
}
case Expression::DataDropId: {
  auto* source = task.source->cast<DataDrop>();
  auto* copy = wasm.allocator.alloc<DataDrop>();
  *task.destPointer = copy;
  copy->segment = source->segment;
  copy->type = source->type;
  break;
}
case Expression::MemoryCopyId: {
  auto* source = task.source->cast<MemoryCopy>();
  auto* copy = wasm.allocator.alloc<MemoryCopy>();
  *task.destPointer = copy;
  tasks.push_back({source->dest, &copy->dest});
  tasks.push_back({source->source, &copy->source});
  tasks.push_back({source->size, &copy->size});
  copy->type = source->type;
  break;
}
case Expression::MemoryFillId: {
  auto* source = task.source->cast<MemoryFill>();
  auto* copy = wasm.allocator.alloc<MemoryFill>();
  *task.destPointer = copy;
  tasks.push_back({source->dest, &copy->dest});
  tasks.push_back({source->value, &copy->value});
  tasks.push_back({source->size, &copy->size});
  copy->type = source->type;
  break;
}
case Expression::ConstId: {
  auto* source = task.source->cast<Const>();
  auto* copy = wasm.allocator.alloc<Const>();
  *task.destPointer = copy;
  copy->value = source->value;
  copy->type = source->type;
  break;
}
case Expression::UnaryId: {
  auto* source = task.source->cast<Unary>();
  auto* copy = wasm.allocator.alloc<Unary>();
  *task.destPointer = copy;
  copy->op = source->op;
  tasks.push_back({source->value, &copy->value});
  copy->type = source->type;
  break;
}
case Expression::BinaryId: {
  auto* source = task.source->cast<Binary>();
  auto* copy = wasm.allocator.alloc<Binary>();
  *task.destPointer = copy;
  copy->op = source->op;
  tasks.push_back({source->left, &copy->left});
  tasks.push_back({source->right, &copy->right});
  copy->type = source->type;
  break;
}
case Expression::SelectId: {
  auto* source = task.source->cast<Select>();
  auto* copy = wasm.allocator.alloc<Select>();
  *task.destPointer = copy;
  tasks.push_back({source->ifTrue, &copy->ifTrue});
  tasks.push_back({source->ifFalse, &copy->ifFalse});
  tasks.push_back({source->condition, &copy->condition});
  copy->type = source->type;
  break;
}
case Expression::DropId: {
  auto* source = task.source->cast<Drop>();
  auto* copy = wasm.allocator.alloc<Drop>();
  *task.destPointer = copy;
  tasks.push_back({source->value, &copy->value});
  copy->type = source->type;
  break;
}
case Expression::ReturnId: {
  auto* source = task.source->cast<Return>();
  auto* copy = wasm.allocator.alloc<Return>();
  *task.destPointer = copy;
  tasks.push_back({source->value, &copy->value});
  copy->type = source->type;
  break;
}
case Expression::MemorySizeId: {
  auto* source = task.source->cast<MemorySize>();
  auto* copy = wasm.allocator.alloc<MemorySize>();
  *task.destPointer = copy;
  copy->ptrType = source->ptrType;
  copy->type = source->type;
  break;
}
case Expression::MemoryGrowId: {
  auto* source = task.source->cast<MemoryGrow>();
  auto* copy = wasm.allocator.alloc<MemoryGrow>();
  *task.destPointer = copy;
  tasks.push_back({source->delta, &copy->delta});
  copy->ptrType = source->ptrType;
  copy->type = source->type;
  break;
}
case Expression::UnreachableId: {
  auto* source = task.source->cast<Unreachable>();
  auto* copy = wasm.allocator.alloc<Unreachable>();
  *task.destPointer = copy;
  copy->type = source->type;
  break;
}
case Expression::PopId: {
  auto* source = task.source->cast<Pop>();
  auto* copy = wasm.allocator.alloc<Pop>();
  *task.destPointer = copy;
  copy->type = source->type;
  break;
}
case Expression::RefNullId: {
  auto* source = task.source->cast<RefNull>();
  auto* copy = wasm.allocator.alloc<RefNull>();
  *task.destPointer = copy;
  copy->type = source->type;
  break;
}
case Expression::RefIsNullId: {
  auto* source = task.source->cast<RefIsNull>();
  auto* copy = wasm.allocator.alloc<RefIsNull>();
  *task.destPointer = copy;
  tasks.push_back({source->value, &copy->value});
  copy->type = source->type;
  break;
}
case Expression::RefFuncId: {
  auto* source = task.source->cast<RefFunc>();
  auto* copy = wasm.allocator.alloc<RefFunc>();
  *task.destPointer = copy;
  copy->func = source->func;
  copy->type = source->type;
  break;
}
case Expression::RefEqId: {
  auto* source = task.source->cast<RefEq>();
  auto* copy = wasm.allocator.alloc<RefEq>();
  *task.destPointer = copy;
  tasks.push_back({source->left, &copy->left});
  tasks.push_back({source->right, &copy->right});
  copy->type = source->type;
  break;
}
case Expression::TryId: {
  auto* source = task.source->cast<Try>();
  auto* copy = wasm.allocator.alloc<Try>();
  *task.destPointer = copy;
  tasks.push_back({source->body, &copy->body});
  tasks.push_back({source->catchBody, &copy->catchBody});
  copy->type = source->type;
  break;
}
case Expression::ThrowId: {
  auto* source = task.source->cast<Throw>();
  auto* copy = wasm.allocator.alloc<Throw>();
  *task.destPointer = copy;
  copy->event = source->event;
  copy->operands.resize(source->operands.size());
  for (Index i = 0; i < source->operands.size(); i++) {
    tasks.push_back({source->operands[i], &copy->operands[i]});
  }
  copy->type = source->type;
  break;
}
case Expression::RethrowId: {
  auto* source = task.source->cast<Rethrow>();
  auto* copy = wasm.allocator.alloc<Rethrow>();
  *task.destPointer = copy;
  tasks.push_back({source->exnref, &copy->exnref});
  copy->type = source->type;
  break;
}
case Expression::BrOnExnId: {
  auto* source = task.source->cast<BrOnExn>();
  auto* copy = wasm.allocator.alloc<BrOnExn>();
  *task.destPointer = copy;
  copy->name = source->name;
  copy->event = source->event;
  tasks.push_back({source->exnref, &copy->exnref});
  copy->sent = source->sent;
  copy->type = source->type;
  break;
}
case Expression::TupleMakeId: {
  auto* source = task.source->cast<TupleMake>();
  auto* copy = wasm.allocator.alloc<TupleMake>();
  *task.destPointer = copy;
  copy->operands.resize(source->operands.size());
  for (Index i = 0; i < source->operands.size(); i++) {
    tasks.push_back({source->operands[i], &copy->operands[i]});
  }
  copy->type = source->type;
  break;
}
case Expression::TupleExtractId: {
  auto* source = task.source->cast<TupleExtract>();
  auto* copy = wasm.allocator.alloc<TupleExtract>();
  *task.destPointer = copy;
  tasks.push_back({source->tuple, &copy->tuple});
  copy->index = source->index;
  copy->type = source->type;
  break;
}
case Expression::I31NewId: {
  auto* source = task.source->cast<I31New>();
  auto* copy = wasm.allocator.alloc<I31New>();
  *task.destPointer = copy;
  tasks.push_back({source->value, &copy->value});
  copy->type = source->type;
  break;
}
case Expression::I31GetId: {
  auto* source = task.source->cast<I31Get>();
  auto* copy = wasm.allocator.alloc<I31Get>();
  *task.destPointer = copy;
  tasks.push_back({source->i31, &copy->i31});
  copy->signed_ = source->signed_;
  copy->type = source->type;
  break;
}
case Expression::RefTestId: {
  auto* source = task.source->cast<RefTest>();
  auto* copy = wasm.allocator.alloc<RefTest>();
  *task.destPointer = copy;
  copy->type = source->type;
  break;
}
case Expression::RefCastId: {
  auto* source = task.source->cast<RefCast>();
  auto* copy = wasm.allocator.alloc<RefCast>();
  *task.destPointer = copy;
  copy->type = source->type;
  break;
}
case Expression::BrOnCastId: {
  auto* source = task.source->cast<BrOnCast>();
  auto* copy = wasm.allocator.alloc<BrOnCast>();
  *task.destPointer = copy;
  copy->type = source->type;
  break;
}
case Expression::RttCanonId: {
  auto* source = task.source->cast<RttCanon>();
  auto* copy = wasm.allocator.alloc<RttCanon>();
  *task.destPointer = copy;
  copy->type = source->type;
  break;
}
case Expression::RttSubId: {
  auto* source = task.source->cast<RttSub>();
  auto* copy = wasm.allocator.alloc<RttSub>();
  *task.destPointer = copy;
  copy->type = source->type;
  break;
}
case Expression::StructNewId: {
  auto* source = task.source->cast<StructNew>();
  auto* copy = wasm.allocator.alloc<StructNew>();
  *task.destPointer = copy;
  copy->type = source->type;
  break;
}
case Expression::StructGetId: {
  auto* source = task.source->cast<StructGet>();
  auto* copy = wasm.allocator.alloc<StructGet>();
  *task.destPointer = copy;
  copy->type = source->type;
  break;
}
case Expression::StructSetId: {
  auto* source = task.source->cast<StructSet>();
  auto* copy = wasm.allocator.alloc<StructSet>();
  *task.destPointer = copy;
  copy->type = source->type;
  break;
}
case Expression::ArrayNewId: {
  auto* source = task.source->cast<ArrayNew>();
  auto* copy = wasm.allocator.alloc<ArrayNew>();
  *task.destPointer = copy;
  copy->type = source->type;
  break;
}
case Expression::ArrayGetId: {
  auto* source = task.source->cast<ArrayGet>();
  auto* copy = wasm.allocator.alloc<ArrayGet>();
  *task.destPointer = copy;
  copy->type = source->type;
  break;
}
case Expression::ArraySetId: {
  auto* source = task.source->cast<ArraySet>();
  auto* copy = wasm.allocator.alloc<ArraySet>();
  *task.destPointer = copy;
  copy->type = source->type;
  break;
}
case Expression::ArrayLenId: {
  auto* source = task.source->cast<ArrayLen>();
  auto* copy = wasm.allocator.alloc<ArrayLen>();
  *task.destPointer = copy;
  copy->type = source->type;
  break;
}
