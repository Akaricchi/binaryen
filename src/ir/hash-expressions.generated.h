  /*
   * Copyright 2020 WebAssembly Community Group participants
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   *     http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   */

  //=============================================================================
  // This is an AUTOGENERATED file, even though it looks human-readable! Do not
  // edit it by hand, instead edit the generator, gen-exprs.py
  //
  // You can and should treat it like human-written code in all other ways,
  // though, like reviewing it in a PR, etc.
  //=============================================================================

case Expression::NopId: {
  break;
}
case Expression::BlockId: {
  auto* cast = curr->cast<Block>();
  noteScopeName(cast->name);
  for (auto* child : cast->list) {
    stack.push_back(child);
  }
  break;
}
case Expression::IfId: {
  auto* cast = curr->cast<If>();
  stack.push_back(cast->condition);
  stack.push_back(cast->ifTrue);
  stack.push_back(cast->ifFalse);
  break;
}
case Expression::LoopId: {
  auto* cast = curr->cast<Loop>();
  noteScopeName(cast->name);
  stack.push_back(cast->body);
  break;
}
case Expression::BreakId: {
  auto* cast = curr->cast<Break>();
  visitScopeName(cast->name);
  stack.push_back(cast->value);
  stack.push_back(cast->condition);
  break;
}
case Expression::SwitchId: {
  auto* cast = curr->cast<Switch>();
  for (Index i = 0; i < cast->targets.size(); i++) {
    visitScopeName(cast->targets[i]);
  }
  visitScopeName(cast->default_);
  stack.push_back(cast->value);
  stack.push_back(cast->condition);
  break;
}
case Expression::CallId: {
  auto* cast = curr->cast<Call>();
  for (auto* child : cast->operands) {
    stack.push_back(child);
  }
  visitNonScopeName(cast->target);
  rehash(digest, cast->isReturn);
  break;
}
case Expression::CallIndirectId: {
  auto* cast = curr->cast<CallIndirect>();
  rehash(digest, cast->sig);
  for (auto* child : cast->operands) {
    stack.push_back(child);
  }
  stack.push_back(cast->target);
  rehash(digest, cast->isReturn);
  break;
}
case Expression::LocalGetId: {
  auto* cast = curr->cast<LocalGet>();
  rehash(digest, cast->index);
  break;
}
case Expression::LocalSetId: {
  auto* cast = curr->cast<LocalSet>();
  rehash(digest, cast->index);
  stack.push_back(cast->value);
  break;
}
case Expression::GlobalGetId: {
  auto* cast = curr->cast<GlobalGet>();
  visitNonScopeName(cast->name);
  break;
}
case Expression::GlobalSetId: {
  auto* cast = curr->cast<GlobalSet>();
  visitNonScopeName(cast->name);
  stack.push_back(cast->value);
  break;
}
case Expression::LoadId: {
  auto* cast = curr->cast<Load>();
  rehash(digest, cast->bytes);
  rehash(digest, cast->signed_);
  visitAddress(cast->offset);
  visitAddress(cast->align);
  rehash(digest, cast->isAtomic);
  stack.push_back(cast->ptr);
  break;
}
case Expression::StoreId: {
  auto* cast = curr->cast<Store>();
  rehash(digest, cast->bytes);
  visitAddress(cast->offset);
  visitAddress(cast->align);
  rehash(digest, cast->isAtomic);
  stack.push_back(cast->ptr);
  stack.push_back(cast->value);
  visitType(cast->valueType);
  break;
}
case Expression::AtomicRMWId: {
  auto* cast = curr->cast<AtomicRMW>();
  rehash(digest, cast->op);
  rehash(digest, cast->bytes);
  visitAddress(cast->offset);
  stack.push_back(cast->ptr);
  stack.push_back(cast->value);
  break;
}
case Expression::AtomicCmpxchgId: {
  auto* cast = curr->cast<AtomicCmpxchg>();
  rehash(digest, cast->bytes);
  visitAddress(cast->offset);
  stack.push_back(cast->ptr);
  stack.push_back(cast->expected);
  stack.push_back(cast->replacement);
  break;
}
case Expression::AtomicWaitId: {
  auto* cast = curr->cast<AtomicWait>();
  visitAddress(cast->offset);
  stack.push_back(cast->ptr);
  stack.push_back(cast->expected);
  stack.push_back(cast->timeout);
  visitType(cast->expectedType);
  break;
}
case Expression::AtomicNotifyId: {
  auto* cast = curr->cast<AtomicNotify>();
  visitAddress(cast->offset);
  stack.push_back(cast->ptr);
  stack.push_back(cast->notifyCount);
  break;
}
case Expression::AtomicFenceId: {
  auto* cast = curr->cast<AtomicFence>();
  rehash(digest, cast->order);
  break;
}
case Expression::SIMDExtractId: {
  auto* cast = curr->cast<SIMDExtract>();
  rehash(digest, cast->op);
  stack.push_back(cast->vec);
  rehash(digest, cast->index);
  break;
}
case Expression::SIMDReplaceId: {
  auto* cast = curr->cast<SIMDReplace>();
  rehash(digest, cast->op);
  stack.push_back(cast->vec);
  rehash(digest, cast->index);
  stack.push_back(cast->value);
  break;
}
case Expression::SIMDShuffleId: {
  auto* cast = curr->cast<SIMDShuffle>();
  stack.push_back(cast->left);
  stack.push_back(cast->right);
  for (auto x : cast->mask) {
    rehash(digest, x);
  }
  break;
}
case Expression::SIMDTernaryId: {
  auto* cast = curr->cast<SIMDTernary>();
  rehash(digest, cast->op);
  stack.push_back(cast->a);
  stack.push_back(cast->b);
  stack.push_back(cast->c);
  break;
}
case Expression::SIMDShiftId: {
  auto* cast = curr->cast<SIMDShift>();
  rehash(digest, cast->op);
  stack.push_back(cast->vec);
  stack.push_back(cast->shift);
  break;
}
case Expression::SIMDLoadId: {
  auto* cast = curr->cast<SIMDLoad>();
  rehash(digest, cast->op);
  visitAddress(cast->offset);
  visitAddress(cast->align);
  stack.push_back(cast->ptr);
  break;
}
case Expression::MemoryInitId: {
  auto* cast = curr->cast<MemoryInit>();
  rehash(digest, cast->segment);
  stack.push_back(cast->dest);
  stack.push_back(cast->offset);
  stack.push_back(cast->size);
  break;
}
case Expression::DataDropId: {
  auto* cast = curr->cast<DataDrop>();
  rehash(digest, cast->segment);
  break;
}
case Expression::MemoryCopyId: {
  auto* cast = curr->cast<MemoryCopy>();
  stack.push_back(cast->dest);
  stack.push_back(cast->source);
  stack.push_back(cast->size);
  break;
}
case Expression::MemoryFillId: {
  auto* cast = curr->cast<MemoryFill>();
  stack.push_back(cast->dest);
  stack.push_back(cast->value);
  stack.push_back(cast->size);
  break;
}
case Expression::ConstId: {
  auto* cast = curr->cast<Const>();
  rehash(digest, cast->value);
  break;
}
case Expression::UnaryId: {
  auto* cast = curr->cast<Unary>();
  rehash(digest, cast->op);
  stack.push_back(cast->value);
  break;
}
case Expression::BinaryId: {
  auto* cast = curr->cast<Binary>();
  rehash(digest, cast->op);
  stack.push_back(cast->left);
  stack.push_back(cast->right);
  break;
}
case Expression::SelectId: {
  auto* cast = curr->cast<Select>();
  stack.push_back(cast->ifTrue);
  stack.push_back(cast->ifFalse);
  stack.push_back(cast->condition);
  break;
}
case Expression::DropId: {
  auto* cast = curr->cast<Drop>();
  stack.push_back(cast->value);
  break;
}
case Expression::ReturnId: {
  auto* cast = curr->cast<Return>();
  stack.push_back(cast->value);
  break;
}
case Expression::MemorySizeId: {
  auto* cast = curr->cast<MemorySize>();
  visitType(cast->ptrType);
  break;
}
case Expression::MemoryGrowId: {
  auto* cast = curr->cast<MemoryGrow>();
  stack.push_back(cast->delta);
  visitType(cast->ptrType);
  break;
}
case Expression::UnreachableId: {
  break;
}
case Expression::PopId: {
  break;
}
case Expression::RefNullId: {
  break;
}
case Expression::RefIsNullId: {
  auto* cast = curr->cast<RefIsNull>();
  stack.push_back(cast->value);
  break;
}
case Expression::RefFuncId: {
  auto* cast = curr->cast<RefFunc>();
  visitNonScopeName(cast->func);
  break;
}
case Expression::RefEqId: {
  auto* cast = curr->cast<RefEq>();
  stack.push_back(cast->left);
  stack.push_back(cast->right);
  break;
}
case Expression::TryId: {
  auto* cast = curr->cast<Try>();
  stack.push_back(cast->body);
  stack.push_back(cast->catchBody);
  break;
}
case Expression::ThrowId: {
  auto* cast = curr->cast<Throw>();
  visitNonScopeName(cast->event);
  for (auto* child : cast->operands) {
    stack.push_back(child);
  }
  break;
}
case Expression::RethrowId: {
  auto* cast = curr->cast<Rethrow>();
  stack.push_back(cast->exnref);
  break;
}
case Expression::BrOnExnId: {
  auto* cast = curr->cast<BrOnExn>();
  visitScopeName(cast->name);
  visitNonScopeName(cast->event);
  stack.push_back(cast->exnref);
  visitType(cast->sent);
  break;
}
case Expression::TupleMakeId: {
  auto* cast = curr->cast<TupleMake>();
  for (auto* child : cast->operands) {
    stack.push_back(child);
  }
  break;
}
case Expression::TupleExtractId: {
  auto* cast = curr->cast<TupleExtract>();
  stack.push_back(cast->tuple);
  rehash(digest, cast->index);
  break;
}
case Expression::I31NewId: {
  auto* cast = curr->cast<I31New>();
  stack.push_back(cast->value);
  break;
}
case Expression::I31GetId: {
  auto* cast = curr->cast<I31Get>();
  stack.push_back(cast->i31);
  rehash(digest, cast->signed_);
  break;
}
case Expression::RefTestId: {
  break;
}
case Expression::RefCastId: {
  break;
}
case Expression::BrOnCastId: {
  break;
}
case Expression::RttCanonId: {
  break;
}
case Expression::RttSubId: {
  break;
}
case Expression::StructNewId: {
  break;
}
case Expression::StructGetId: {
  break;
}
case Expression::StructSetId: {
  break;
}
case Expression::ArrayNewId: {
  break;
}
case Expression::ArrayGetId: {
  break;
}
case Expression::ArraySetId: {
  break;
}
case Expression::ArrayLenId: {
  break;
}
